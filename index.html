<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <script src="pouchdb.js"></script>
    <script src="pouchdb.indexeddb.js"></script>
    <title>PouchDB purge demo</title>
  </head>
  <body>
    <h1>PouchDB purge demo</h1>

    <p>
      In your browser console, run <code>createTree()</code> to create an
      example document with conflicts and respective rev tree branches. The tree
      structure will be written to the console. With
      <code>attemptPurge(revHash)</code>, you can attempt to do a purge on that
      rev. Refer to the current implementation to learn about the progress of
      that function.
    </p>

    <script>
      let db1,
        db2,
        i = 0;
      const adapter = "indexeddb";

      async function clearDatabase(name) {
        try {
          const _db = new PouchDB(name, { adapter });
          await _db.destroy();
        } catch {}
      }

      function findPathToLeaf(revs, targetRev) {
        // `revs` has the same structure as what `revs_tree` has on e.g. the IndexedDB representation
        // of the rev tree datastructure.
        let path = [];
        const toVisit = revs.slice();

        let node;
        while ((node = toVisit.pop())) {
          const { pos, ids: tree } = node;
          const rev = `${pos}-${tree[0]}`;
          const branches = tree[2];

          // just assuming we're already working on the path up towards our desired leaf.
          path.push(rev);

          // we've reached the leaf of our dreams, so return the computed path.
          if (rev === targetRev) return path.reverse();

          // this is based on the assumption that after we have a leaf (`branches.length == 0`), we handle the next
          // branch. this is true for all branches other than the path leading to the winning rev (which is 6-a in
          // the example below. i've added a reset condition for branching nodes (`branches.length > 1`) as well.
          if (branches.length === 0 || branches.length > 1) {
            path = [];
          }

          // as a next step, we push the branches of this node to `toVisit` for visiting it during the next iteration
          for (let i = 0, len = branches.length; i < len; i++) {
            toVisit.push({ pos: pos + 1, ids: branches[i] });
          }
        }
        return path.reverse();
      }

      // attempt to purge the doc used in the example below with a given rev.
      async function attemptPurge(rev = "6-3f7f6c55c27bf54c009b661607a9fe05") {
        const docId = "something";

        return new Promise((resolve) => {
          db1._getRevisionTree(docId, async (whatever, revs) => {
            const path = findPathToLeaf(revs, rev);
            console.log("purge path", path);

            for (const revHash of path) {
              await (async () =>
                new Promise((resolve) =>
                  db1._purge(docId, revHash, (err) => {
                    if (err) {
                      console.error("error", err);
                    } else {
                      console.log("purge successful");
                    }
                    resolve();
                  })
                ))();
            }

            console.log(
              "revs_info after purge",
              await db1.get("something", { revs_info: true })
            );

            resolve();
          });
        });
      }

      /*
       * 1-a - 2-a -- 3-a - 4-a - 5-a - 6-a
       *           \           \
       *            \            5-c - 6-c
       *              3-b - 4-b
       *
       * three leaves: 6-a, 6-c, and 4-b.
       * 6-a is the winning leaf.
       *
       * ~ ~ ~
       *
       * rev hashes:
       * 1-a 1-9692d401ed2d3434827608278bdc36e3
       * 2-a 2-37aa033df08c21b4f56f1da2081e9e00
       * 3-a 3-df226cb9a2e5bdd3e6be009fd51f47c1
       * 4-a 4-6e94d345514a08620c3176eea080d3ec
       * 5-a 5-df4a81cd21c75c71974d96e88a68fc2f
       * 6-a 6-3f7f6c55c27bf54c009b661607a9fe05 leaf
       * 5-c 5-0b84bfea5508e2020feb07384714a987
       * 6-c 6-2d0ab4f4089a57c95d52bfd2d66b823d leaf
       * 3-b 3-43f6d5557d6de39488c64bb2c684ae7c
       * 4-b 4-a3b44168027079c2692a7d8eb35e9643 leaf
       */
      async function createTree() {
        try {
          await clearDatabase("db1");
          await clearDatabase("db2");

          db1 = new PouchDB("db1", { adapter });
          db2 = new PouchDB("db2", { adapter });
          const docId = "something";

          console.log(`Building the following rev tree for doc \`${docId}\`:
1-a - 2-a -- 3-a - 4-a - 5-a - 6-a
          \\            \\
           \\             5-c - 6-c
             3-b - 4-b

Individual rev hashes:
1-a 1-9692d401ed2d3434827608278bdc36e3
2-a 2-37aa033df08c21b4f56f1da2081e9e00
3-a 3-df226cb9a2e5bdd3e6be009fd51f47c1
4-a 4-6e94d345514a08620c3176eea080d3ec
5-a 5-df4a81cd21c75c71974d96e88a68fc2f
6-a 6-3f7f6c55c27bf54c009b661607a9fe05 leaf
5-c 5-0b84bfea5508e2020feb07384714a987
6-c 6-2d0ab4f4089a57c95d52bfd2d66b823d leaf
3-b 3-43f6d5557d6de39488c64bb2c684ae7c
4-b 4-a3b44168027079c2692a7d8eb35e9643 leaf`);

          const doc_1a = await db1.put({ _id: docId, key: "1-a" });
          const doc_2a = await db1.put({
            _id: docId,
            _rev: doc_1a.rev,
            key: "2-a",
          });

          await PouchDB.sync(db1, db2);

          const doc_3a = await db1.put({
            _id: docId,
            _rev: doc_2a.rev,
            key: "3-a",
          });
          const doc_3b = await db2.put({
            _id: docId,
            _rev: doc_2a.rev,
            key: "3-b",
          });

          const doc_4a = await db1.put({
            _id: docId,
            _rev: doc_3a.rev,
            key: "4-a",
          });
          const doc_4b = await db2.put({
            _id: docId,
            _rev: doc_3b.rev,
            key: "4-b",
          });

          await PouchDB.sync(db2, db1);

          const doc_5a = await db1.put({
            _id: docId,
            _rev: doc_4a.rev,
            key: "5-a",
          });
          const doc_6a = await db1.put({
            _id: docId,
            _rev: doc_5a.rev,
            key: "6-a",
          });

          const doc_5b = await db2.put({
            _id: docId,
            _rev: doc_4a.rev,
            key: "5-b",
          });
          const doc_6b = await db2.put({
            _id: docId,
            _rev: doc_5b.rev,
            key: "6-b",
          });

          await PouchDB.sync(db2, db1);
        } catch (err) {
          console.error(err);
        }
      }
    </script>
  </body>
</html>
